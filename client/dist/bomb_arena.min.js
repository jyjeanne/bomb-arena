(function(){function r(e,n,t){function o(i,f){if(!n[i]){if(!e[i]){var c="function"==typeof require&&require;if(!f&&c)return c(i,!0);if(u)return u(i,!0);var a=new Error("Cannot find module '"+i+"'");throw a.code="MODULE_NOT_FOUND",a}var p=n[i]={exports:{}};e[i][0].call(p.exports,function(r){var n=e[i][1][r];return o(n||r)},p,p.exports,r,e,n,t)}return n[i].exports}for(var u="function"==typeof require&&require,i=0;i<t.length;i++)o(t[i]);return o}return r})()({1:[function(require,module,exports){
var AudioPlayer = require("../util/audio_player");
var TextureUtil = require("../util/texture_util");

function getFrame(prefix, number) {
  return "gamesprites/" + prefix + "/" + prefix + "_" + number + ".png";
}

// Phaser 3: Convert to ES6 class extending Phaser.Physics.Arcade.Sprite
class Bomb extends Phaser.Physics.Arcade.Sprite {
  constructor(scene, x, y, id) {
    super(scene, x, y, TEXTURES, "gamesprites/bomb/bomb_01.png");

    this.scene = scene;
    this.id = id;

    this.setOrigin(0.5, 0.5);

    scene.add.existing(this);
    scene.physics.add.existing(this);

    this.body.immovable = true;

    // Add shadow under bomb
    this.shadow = scene.add.ellipse(x, y + 10, 20, 8, 0x000000, 0.3);
    this.shadow.setDepth(0);

    // Add glow effect
    this.glow = scene.add.circle(x, y, 16, 0xffaa00, 0);
    this.glow.setDepth(5);
    this.glow.setBlendMode(Phaser.BlendModes.ADD);

    // Phaser 3: tweens.add instead of game.add.tween
    this.sizeTween = scene.tweens.add({
      targets: this.scale,
      x: 1.2,
      y: 1.2,
      duration: 500,
      ease: 'Linear',
      yoyo: true,
      repeat: -1
    });

    // Pulsing glow effect that intensifies over time
    scene.tweens.add({
      targets: this.glow,
      alpha: 0.6,
      scale: 1.5,
      duration: 500,
      ease: 'Sine.easeInOut',
      yoyo: true,
      repeat: -1
    });
  }

  remove() {
    if (this.sizeTween) {
      this.sizeTween.stop();
    }
    if (this.shadow) {
      this.shadow.destroy();
    }
    if (this.glow) {
      this.glow.destroy();
    }
    this.destroy();
  }

  // Static method for rendering explosions
  static renderExplosion(scene, explosions) {
    // Screen shake effect
    scene.cameras.main.shake(300, 0.01);

    explosions.forEach(function(explosion) {
      const explosionSprite = scene.add.sprite(explosion.x, explosion.y, TEXTURES, getFrame(explosion.key, "01"));
      explosionSprite.setOrigin(0.5, 0.5);

      // Add flash effect
      const flash = scene.add.circle(explosion.x, explosion.y, 30, 0xffff00, 1);
      flash.setDepth(15);
      flash.setBlendMode(Phaser.BlendModes.ADD);
      scene.tweens.add({
        targets: flash,
        alpha: 0,
        scale: 3,
        duration: 300,
        ease: 'Cubic.easeOut',
        onComplete: () => flash.destroy()
      });

      // Create particle emitter for fire/smoke effect
      const particles = scene.add.particles(explosion.x, explosion.y, TEXTURES, {
        frame: 'gamesprites/bomb/bomb_01.png',
        speed: { min: 50, max: 150 },
        angle: { min: 0, max: 360 },
        scale: { start: 0.3, end: 0 },
        alpha: { start: 0.8, end: 0 },
        lifespan: 600,
        blendMode: 'ADD',
        tint: [0xff6600, 0xff3300, 0xffaa00],
        quantity: 15,
        duration: 100
      });
      particles.setDepth(12);

      // Clean up particles after they're done
      scene.time.delayedCall(800, () => {
        particles.destroy();
      });

      // Create animation if it doesn't exist
      const animKey = `explosion_${explosion.key}`;
      if (!scene.anims.exists(animKey)) {
        const frames = TextureUtil.getFrames(getFrame, explosion.key, ["02", "03", "04", "05"]);
        scene.anims.create({
          key: animKey,
          frames: frames.map(frame => ({ key: TEXTURES, frame: frame })),
          frameRate: 17,
          repeat: 0
        });
      }

      // Phaser 3: on('animationcomplete') instead of onComplete
      explosionSprite.on('animationcomplete', () => {
        scene.deadGroup.push(explosionSprite);
      });

      // Set depth based on hide flag
      if(explosion.hide) {
        explosionSprite.setDepth(1);
      } else {
        explosionSprite.setDepth(10);
      }

      explosionSprite.play(animKey);
      AudioPlayer.playBombSound();
    });
  }
}

module.exports = Bomb;

},{"../util/audio_player":14,"../util/texture_util":19}],2:[function(require,module,exports){
var Bomb = require("./bomb");
var TextureUtil = require("../util/texture_util");

var DEFAULT_PLAYER_SPEED = 180;
var PLAYER_SPEED_POWERUP_INCREMENT = 60;

// Phaser 3: Sprite class signature changed
class Player extends Phaser.Physics.Arcade.Sprite {
  constructor(scene, x, y, id, color) {
    const firstFrame = Player.prototype.getFrame(color, "01");
    super(scene, x, y, TEXTURES, firstFrame);

    this.scene = scene;
    this.spawnPoint = {x: x, y: y};
    this.id = id;
    this.facing = "down";
    this.setOrigin(0.5, 0.5); // Phaser 3: setOrigin instead of anchor.setTo
    this.bombButtonJustPressed = false;
    this.speed = DEFAULT_PLAYER_SPEED;
    this.firstFrame = firstFrame;
    this.color = color;

    // Phaser 3: physics is enabled by default for Physics.Arcade.Sprite
    scene.add.existing(this);
    scene.physics.add.existing(this);

    // Phaser 3: Set body size and offset (offset is from sprite origin, not anchor)
    // Player sprite is roughly 32x32, but body should be smaller for better gameplay
    this.body.setSize(20, 20);
    this.body.setOffset(6, 12); // Center the collision box on the character's feet area

    // Add shadow under player
    this.shadow = scene.add.ellipse(x, y + 12, 18, 6, 0x000000, 0.4);
    this.shadow.setDepth(-1);

    // Create animations for this player color
    this.createAnimations(color);
  }

  createAnimations(color) {
    const downFrames = TextureUtil.getFrames(this.getFrame, color, ["01", "02", "03", "04", "05"]);
    const upFrames = TextureUtil.getFrames(this.getFrame, color, ["06", "07", "08", "09", "10"]);
    const rightFrames = TextureUtil.getFrames(this.getFrame, color, ["11", "12", "13"]);
    const leftFrames = TextureUtil.getFrames(this.getFrame, color, ["14", "15", "16"]);

    // Phaser 3: animations are created globally or per sprite
    const animKey = `player_${color}`;

    if (!this.scene.anims.exists(`${animKey}_down`)) {
      this.scene.anims.create({
        key: `${animKey}_down`,
        frames: downFrames.map(frame => ({ key: TEXTURES, frame: frame })),
        frameRate: 10,
        repeat: -1
      });
    }

    if (!this.scene.anims.exists(`${animKey}_up`)) {
      this.scene.anims.create({
        key: `${animKey}_up`,
        frames: upFrames.map(frame => ({ key: TEXTURES, frame: frame })),
        frameRate: 10,
        repeat: -1
      });
    }

    if (!this.scene.anims.exists(`${animKey}_right`)) {
      this.scene.anims.create({
        key: `${animKey}_right`,
        frames: rightFrames.map(frame => ({ key: TEXTURES, frame: frame })),
        frameRate: 10,
        repeat: -1
      });
    }

    if (!this.scene.anims.exists(`${animKey}_left`)) {
      this.scene.anims.create({
        key: `${animKey}_left`,
        frames: leftFrames.map(frame => ({ key: TEXTURES, frame: frame })),
        frameRate: 10,
        repeat: -1
      });
    }

    this.animKey = animKey;
  }

  handleInput() {
    this.handleMotionInput();
    this.handleBombInput();
  }

  handleMotionInput() {
    let moving = true;

    // Phaser 3: collision is handled in Level scene via physics.add.collider
    // These collision calls will be moved to the scene

    // Phaser 3: keyboard input changed
    const cursors = this.scene.input.keyboard.createCursorKeys();

    if (cursors.left.isDown) {
      this.body.velocity.y = 0;
      this.body.velocity.x = -this.speed;
      this.facing = "left";
    } else if (cursors.right.isDown) {
      this.body.velocity.y = 0;
      this.body.velocity.x = this.speed;
      this.facing = "right";
    } else if (cursors.up.isDown) {
      this.body.velocity.x = 0;
      this.body.velocity.y = -this.speed;
      this.facing = "up";
    } else if (cursors.down.isDown) {
      this.body.velocity.x = 0;
      this.body.velocity.y = this.speed;
      this.facing = "down";
    } else {
      moving = false;
      this.freeze();
    }

    if(moving) {
      this.play(`${this.animKey}_${this.facing}`, true);
      socket.emit("move player", {x: this.x, y: this.y, facing: this.facing});
    }
  }

  handleBombInput() {
    const spaceKey = this.scene.input.keyboard.addKey(Phaser.Input.Keyboard.KeyCodes.SPACE);

    // Check for bomb overlap in Level scene
    const overlapping = this.scene.physics.overlap(this, this.scene.bombs);

    if(spaceKey.isDown && !overlapping && !this.bombButtonJustPressed) {
      this.bombButtonJustPressed = true;

      // Bombs for a player are identified by timestamp.
      socket.emit("place bomb", {x: this.body.x, y: this.body.y, id: this.scene.time.now});
    } else if(!spaceKey.isDown && this.bombButtonJustPressed) {
      this.bombButtonJustPressed = false;
    }
  }

  preUpdate(time, delta) {
    super.preUpdate(time, delta);

    // Update shadow position to follow player
    if (this.shadow) {
      this.shadow.x = this.x;
      this.shadow.y = this.y + 12;
    }
  }

  freeze() {
    this.body.velocity.x = 0;
    this.body.velocity.y = 0;
    this.stop(); // Phaser 3: stop() instead of animations.stop()
  }

  applySpeedPowerup() {
    this.speed += PLAYER_SPEED_POWERUP_INCREMENT;
  }

  celebrate() {
    // Victory jump animation
    this.scene.tweens.add({
      targets: this,
      y: this.y - 30,
      duration: 400,
      ease: 'Quad.easeOut',
      yoyo: true,
      repeat: 2,
      onUpdate: () => {
        // Update shadow during jump
        if (this.shadow) {
          this.shadow.y = this.y + 12;
        }
      }
    });

    // Spin animation
    this.scene.tweens.add({
      targets: this,
      angle: 360,
      duration: 800,
      ease: 'Linear',
      repeat: 1
    });

    // Victory particles - confetti effect
    const colors = [0xffff00, 0xff6600, 0x00ff00, 0x0099ff, 0xff00ff];
    const particleEmitter = this.scene.add.particles(this.x, this.y - 20, TEXTURES, {
      frame: 'gamesprites/bomb/bomb_01.png',
      speed: { min: 100, max: 200 },
      angle: { min: -120, max: -60 },
      scale: { start: 0.3, end: 0.1 },
      alpha: { start: 1, end: 0 },
      lifespan: 1000,
      gravityY: 300,
      blendMode: 'ADD',
      tint: colors,
      quantity: 3,
      frequency: 100,
      maxParticles: 30
    });
    particleEmitter.setDepth(15);

    // Stop particles after celebration
    this.scene.time.delayedCall(1600, () => {
      particleEmitter.stop();
      this.scene.time.delayedCall(1000, () => {
        particleEmitter.destroy();
      });
    });
  }

  getFrame(prefix, number) {
    return "gamesprites/bomberman_" + prefix + "/bomberman_" + prefix + "_" + number + ".png";
  }

  reset() {
    this.x = this.spawnPoint.x;
    this.y = this.spawnPoint.y;
    this.setFrame(this.firstFrame);
    this.facing = "down";
    this.bombButtonJustPressed = false;
    this.speed = DEFAULT_PLAYER_SPEED;

    if(!this.active) {
      this.setActive(true);
      this.setVisible(true);
    }

    // Reset shadow visibility and position
    if (this.shadow) {
      this.shadow.setVisible(true);
      this.shadow.x = this.x;
      this.shadow.y = this.y + 12;
    }
  }
}

module.exports = Player;
},{"../util/texture_util":19,"./bomb":1}],3:[function(require,module,exports){
var remotePlayerUpdateInterval = 100;
var TextureUtil = require("../util/texture_util");

function getFrame(color, number) {
  return "gamesprites/bomberman_" + color + "/bomberman_" + color + "_" + number + ".png";
}

// Phaser 3: Convert to ES6 class extending Phaser.Physics.Arcade.Sprite
class RemotePlayer extends Phaser.Physics.Arcade.Sprite {
  constructor(scene, x, y, id, color) {
    const firstFrame = getFrame(color, "01");
    super(scene, x, y, TEXTURES, firstFrame);

    this.scene = scene;
    this.id = id;
    this.color = color;
    this.previousPosition = {x: x, y: y};
    this.lastMoveTime = 0;
    this.targetPosition = null;
    this.spawnPoint = {x: x, y: y};
    this.firstFrame = firstFrame;
    this.distanceToCover = null;
    this.distanceCovered = null;

    scene.add.existing(this);
    scene.physics.add.existing(this);

    this.setOrigin(0.5, 0.5);

    // Add shadow under remote player
    this.shadow = scene.add.ellipse(x, y + 12, 18, 6, 0x000000, 0.4);
    this.shadow.setDepth(-1);

    // Create animations
    this.createAnimations(color);
  }

  createAnimations(color) {
    const downFrames = TextureUtil.getFrames(getFrame, color, ["01", "02", "03", "04", "05"]);
    const upFrames = TextureUtil.getFrames(getFrame, color, ["06", "07", "08", "09", "10"]);
    const rightFrames = TextureUtil.getFrames(getFrame, color, ["11", "12", "13"]);
    const leftFrames = TextureUtil.getFrames(getFrame, color, ["14", "15", "16"]);

    const animKey = `remoteplayer_${color}_${this.id}`;

    if (!this.scene.anims.exists(`${animKey}_down`)) {
      this.scene.anims.create({
        key: `${animKey}_down`,
        frames: downFrames.map(frame => ({ key: TEXTURES, frame: frame })),
        frameRate: 10,
        repeat: -1
      });
    }

    if (!this.scene.anims.exists(`${animKey}_up`)) {
      this.scene.anims.create({
        key: `${animKey}_up`,
        frames: upFrames.map(frame => ({ key: TEXTURES, frame: frame })),
        frameRate: 10,
        repeat: -1
      });
    }

    if (!this.scene.anims.exists(`${animKey}_right`)) {
      this.scene.anims.create({
        key: `${animKey}_right`,
        frames: rightFrames.map(frame => ({ key: TEXTURES, frame: frame })),
        frameRate: 10,
        repeat: -1
      });
    }

    if (!this.scene.anims.exists(`${animKey}_left`)) {
      this.scene.anims.create({
        key: `${animKey}_left`,
        frames: leftFrames.map(frame => ({ key: TEXTURES, frame: frame })),
        frameRate: 10,
        repeat: -1
      });
    }

    this.animKey = animKey;
  }

  interpolate(lastFrameTime) {
    if(this.distanceToCover && lastFrameTime) {
      if((this.distanceCovered.x < Math.abs(this.distanceToCover.x) || this.distanceCovered.y < Math.abs(this.distanceToCover.y))) {
        // Phaser 3: this.scene.time.now instead of game.time.now
        var fractionOfTimeStep = (this.scene.time.now - lastFrameTime) / remotePlayerUpdateInterval;
        var distanceCoveredThisFrameX = fractionOfTimeStep * this.distanceToCover.x;
        var distanceCoveredThisFrameY = fractionOfTimeStep * this.distanceToCover.y;

        this.distanceCovered.x += Math.abs(distanceCoveredThisFrameX);
        this.distanceCovered.y += Math.abs(distanceCoveredThisFrameY);

        this.x += distanceCoveredThisFrameX;
        this.y += distanceCoveredThisFrameY;
      } else {
        this.x = this.targetPosition.x;
        this.y = this.targetPosition.y;
      }
    }

    // Update shadow position
    if (this.shadow) {
      this.shadow.x = this.x;
      this.shadow.y = this.y + 12;
    }
  }

  getFrame(color, number) {
    return getFrame(color, number);
  }

  reset() {
    this.x = this.spawnPoint.x;
    this.y = this.spawnPoint.y;
    this.setFrame(this.firstFrame);
    this.previousPosition = {x: this.x, y: this.y};
    this.distanceToCover = null;
    this.distanceCovered = null;
    this.targetPosition = null;
    this.lastMoveTime = null;

    if(!this.active) {
      this.setActive(true);
      this.setVisible(true);
    }

    // Reset shadow visibility and position
    if (this.shadow) {
      this.shadow.setVisible(true);
      this.shadow.x = this.x;
      this.shadow.y = this.y + 12;
    }
  }

  celebrate() {
    // Victory jump animation
    this.scene.tweens.add({
      targets: this,
      y: this.y - 30,
      duration: 400,
      ease: 'Quad.easeOut',
      yoyo: true,
      repeat: 2,
      onUpdate: () => {
        // Update shadow during jump
        if (this.shadow) {
          this.shadow.y = this.y + 12;
        }
      }
    });

    // Spin animation
    this.scene.tweens.add({
      targets: this,
      angle: 360,
      duration: 800,
      ease: 'Linear',
      repeat: 1
    });

    // Victory particles - confetti effect
    const colors = [0xffff00, 0xff6600, 0x00ff00, 0x0099ff, 0xff00ff];
    const particleEmitter = this.scene.add.particles(this.x, this.y - 20, TEXTURES, {
      frame: 'gamesprites/bomb/bomb_01.png',
      speed: { min: 100, max: 200 },
      angle: { min: -120, max: -60 },
      scale: { start: 0.3, end: 0.1 },
      alpha: { start: 1, end: 0 },
      lifespan: 1000,
      gravityY: 300,
      blendMode: 'ADD',
      tint: colors,
      quantity: 3,
      frequency: 100,
      maxParticles: 30
    });
    particleEmitter.setDepth(15);

    // Stop particles after celebration
    this.scene.time.delayedCall(1600, () => {
      particleEmitter.stop();
      this.scene.time.delayedCall(1000, () => {
        particleEmitter.destroy();
      });
    });
  }
}

module.exports = RemotePlayer;

},{"../util/texture_util":19}],4:[function(require,module,exports){
var TextConfigurer = require('../util/text_configurer');

const screenWidth = 600;
const xOffset = 100 - screenWidth;
const yOffset = 60;
const headerXOffset = 150 - screenWidth;
const headerYOffset = 65;
const winnerPicXOffset = 225 - screenWidth;
const winnerPicYOffset = 310;
const defaultTextXOffset = 220 - screenWidth;
const defaultTextYOffset = 220;
const singleWinnerText = "Winner is...";
const roundEndTieText = "Draw! Winners are...";

// Phaser 3: Convert to Container instead of Group
class RoundEndAnimation extends Phaser.GameObjects.Container {
  constructor(scene, roundNumber, winningColors) {
    super(scene);

    this.scene = scene;
    this.winnerImageIndices = [];

    // Add to scene
    scene.add.existing(this);

    // Create round end window
    const roundEndWindow = scene.add.image(xOffset, yOffset, TEXTURES, "lobby/end_of_round_window.png");
    roundEndWindow.setOrigin(0, 0);

    const header = scene.add.text(headerXOffset, headerYOffset, "Round " + roundNumber + " Complete!");
    TextConfigurer.configureText(header, "white", 32);

    // Text and offset differ based on whether there was a tie
    const actualTextXOffset = winningColors.length > 1 ? defaultTextXOffset - 55 : defaultTextXOffset;
    const actualTextToDisplay = winningColors.length > 1 ? roundEndTieText : singleWinnerText;

    const textObject = scene.add.text(actualTextXOffset, defaultTextYOffset, actualTextToDisplay);
    TextConfigurer.configureText(textObject, "white", 28);
    textObject.setAlpha(0);

    // Add children to container
    this.add(roundEndWindow);
    this.add(header);
    this.add(textObject);

    this.createAndAddWinnerImages(winningColors);
  }

  createAndAddWinnerImages(winningColors) {
    let index = 3; // 3 is the index of the first winner image

    winningColors.forEach((color) => {
      const winnerPicImage = this.scene.add.image(winnerPicXOffset, winnerPicYOffset, TEXTURES, "lobby/bomberman_head/bomberman_head_" + color + ".png");
      winnerPicImage.setOrigin(0, 0);
      winnerPicImage.setScale(1.75, 1.75);
      winnerPicImage.setAlpha(0);

      this.add(winnerPicImage);
      this.winnerImageIndices.push(index++);
    });
  }

  beginAnimation(callback) {
    // Entrance tween
    const entranceTween = this.scene.tweens.add({
      targets: this,
      x: screenWidth,
      duration: 300,
      ease: 'Linear',
      onComplete: () => {
        winnerTextTween.play();
      }
    });

    // Winner text tween
    const winnerTextTween = this.scene.tweens.add({
      targets: this.list[2], // textObject is at index 2
      alpha: 1,
      duration: 800,
      ease: 'Linear',
      paused: true,
      onComplete: () => {
        winnerDisplayTween.play();
      }
    });

    // Exit tween
    const exitTween = this.scene.tweens.add({
      targets: this,
      x: 2 * screenWidth,
      duration: 300,
      delay: 200,
      ease: 'Linear',
      paused: true,
      onComplete: () => {
        callback();
        this.destroy();
      }
    });

    // Winner images display tween
    const winnerDisplayTween = this.generateWinnerImageTween(this.winnerImageIndices, exitTween);
  }

  generateWinnerImageTween(indices, nextTween) {
    const winnerImageTweens = [];

    for (let i = 0; i < indices.length; i++) {
      const tween = this.scene.tweens.add({
        targets: this.list[indices[i]],
        alpha: 1,
        duration: 900,
        ease: 'Linear',
        paused: true,
        onComplete: () => {
          if (i < indices.length - 1) {
            // Fade out and start next
            this.scene.tweens.add({
              targets: this.list[indices[i]],
              alpha: 0,
              duration: 900,
              ease: 'Linear',
              onComplete: () => {
                if (winnerImageTweens[i + 1]) {
                  winnerImageTweens[i + 1].play();
                }
              }
            });
          } else {
            // Last winner, start exit tween
            nextTween.play();
          }
        }
      });

      winnerImageTweens.push(tween);
    }

    return winnerImageTweens[0];
  }
}

module.exports = RoundEndAnimation;

},{"../util/text_configurer":18}],5:[function(require,module,exports){
/**
* NOTE: Phaser.Group no longer exists in Phaser 3.
* Groups work differently in Phaser 3 - they use Phaser.GameObjects.Group
* This enhancement is disabled for Phaser 3 migration.
* If needed, this functionality should be reimplemented using Phaser 3 Group API.
*/

// Phaser 2 code - disabled for Phaser 3
/*
Phaser.Group.prototype.removeAll = function (destroy, silent) {

    if (typeof destroy === 'undefined') { destroy = false; }
    if (typeof silent === 'undefined') { silent = false; }

    if (this.children.length === 0)
    {
        return;
    }

    var i = 0;

    do
    {
        if(this.children[i].doNotDestroy) {
            i++;
        }

        if (!silent && this.children[i].events)
        {
            this.children[i].events.onRemovedFromGroup.dispatch(this.children[i], this);
        }

        var removed = this.removeChild(this.children[i]);

        if (destroy && removed)
        {
            removed.destroy(true);
        }
    }
    while (this.children.length > i);

    this.cursor = null;

};
*/
},{}],6:[function(require,module,exports){
var AudioPlayer = require("../util/audio_player");

class Boot extends Phaser.Scene {
  constructor() {
    super({ key: 'Boot' });
    console.log("[BOOT] Scene constructor called");
  }

  preload() {
    console.log("[BOOT] Preload phase");
  }

  create() {
    console.log("[BOOT] Create phase - initializing game");

    // Phaser 3 handles visibility automatically, but you can configure it
    this.game.events.on('hidden', () => {
      console.log("[BOOT] Game hidden");
    });

    this.game.events.on('visible', () => {
      console.log("[BOOT] Game visible");
    });

    AudioPlayer.initialize();
    console.log("[BOOT] Audio player initialized");

    // Phaser 3 scale configuration (should be in game config, but can adjust here)
    if (this.sys.game.device.os.desktop) {
      console.log("[BOOT] Desktop mode detected");
    } else {
      console.log("[BOOT] Mobile mode detected");
    }

    console.log("[BOOT] Starting Preloader scene");
    this.scene.start('Preloader');
  }
}

module.exports = Boot;

},{"../util/audio_player":14}],7:[function(require,module,exports){
var TextConfigurer = require('../util/text_configurer');

class GameOver extends Phaser.Scene {
  constructor() {
    super({ key: 'GameOver' });
  }

  init(data) {
    this.winnerColor = data.gameWinnerColor;
    this.winByDefault = data.noOpponents;
  }

  create() {
    let textToDisplay = this.winByDefault ?
      "     No other players remaining.\n              You win by default." :
      "       Game Over. Winner: " + this.winnerColor;

    textToDisplay += "\n\nPress Enter to return to main menu.";

    const textObject = this.add.text(
      this.cameras.main.width / 2,
      this.cameras.main.height / 2,
      textToDisplay
    );
    textObject.setOrigin(0.5, 0.5);
    TextConfigurer.configureText(textObject, "white", 28);

    // Phaser 3: Create key object
    this.enterKey = this.input.keyboard.addKey(Phaser.Input.Keyboard.KeyCodes.ENTER);
  }

  update() {
    // Phaser 3: Check key state
    if(this.enterKey.isDown) {
      this.returnToLobby();
    }
  }

  returnToLobby() {
    this.scene.start("Lobby");
  }
}

module.exports = GameOver;

},{"../util/text_configurer":18}],8:[function(require,module,exports){
var BLACK_HEX_CODE = 0x000000; // Phaser 3 uses hex number not string
var TILE_SIZE = 40;

var PowerupIDs = require("../../../../common/powerup_ids");
var MapInfo = require("../../../../common/map_info");
var AudioPlayer = require("../util/audio_player");
var Player = require("../entities/player");
var RemotePlayer = require("../entities/remoteplayer");
var Bomb = require("../entities/bomb");
var RoundEndAnimation = require("../entities/round_end_animation");
var PowerupImageKeys = require("../util/powerup_image_keys");
var PowerupNotificationPlayer = require("../util/powerup_notification_player");

class Level extends Phaser.Scene {
  constructor() {
    super({ key: 'Level' });
    this.remotePlayers = {};
    this.gameFrozen = true;
  }

  init(data) {
    // Phaser 3: data passed via object
    this.tilemapName = data.tilemapName;
    this.players = data.players;
    this.playerId = data.id;
  }

  setEventHandlers() {
    // Socket.io event handlers - bind to this scene
    socket.on("disconnect", this.onSocketDisconnect.bind(this));
    socket.on("m", this.onMovePlayer.bind(this));
    socket.on("remove player", this.onRemovePlayer.bind(this));
    socket.on("kill player", this.onKillPlayer.bind(this));
    socket.on("place bomb", this.onPlaceBomb.bind(this));
    socket.on("detonate", this.onDetonate.bind(this));
    socket.on("new round", this.onNewRound.bind(this));
    socket.on("end game", this.onEndGame.bind(this));
    socket.on("no opponents left", this.onNoOpponentsLeft.bind(this));
    socket.on("powerup acquired", this.onPowerupAcquired.bind(this));
  }

  create() {
    window.level = this; // Keep global reference for socket handlers
    this.lastFrameTime = null;
    this.deadGroup = [];
    this.colliders = []; // Store colliders so we can destroy them on restart

    this.initializeMap();
    this.createAtmosphericEffects();

    // Phaser 3: Groups are created differently
    this.bombs = this.physics.add.group();
    this.items = {};

    // Phaser 3: Physics is enabled via physics.add.existing
    // blockLayer physics will be handled via collider

    this.setEventHandlers();
    this.initializePlayers();

    // Set up collisions and store them
    if (window.player) {
      this.colliders.push(this.physics.add.collider(window.player, this.blockLayer));
      this.colliders.push(this.physics.add.collider(window.player, this.bombs));
    }

    this.createDimGraphic();
    this.beginRoundAnimation("round_text/round_1.png");
  }

  createAtmosphericEffects() {
    const width = this.cameras.main.width;
    const height = this.cameras.main.height;

    // Background gradient for depth
    this.backgroundGradient = this.add.graphics();
    this.backgroundGradient.setDepth(-10);

    // Create a subtle radial gradient effect using multiple circles
    const centerX = width / 2;
    const centerY = height / 2;
    const maxRadius = Math.max(width, height);

    for (let i = 0; i < 5; i++) {
      const radius = maxRadius * (1 - i * 0.2);
      const alpha = 0.15 - i * 0.03;
      this.backgroundGradient.fillStyle(0x4a5568, alpha);
      this.backgroundGradient.fillCircle(centerX, centerY, radius);
    }

    // Ambient lighting overlay - warm orange tint
    this.ambientLight = this.add.graphics();
    this.ambientLight.setDepth(-9);
    this.ambientLight.fillStyle(0xff6600, 0.08);
    this.ambientLight.fillRect(0, 0, width, height);

    // Atmospheric particles - slow-moving dust/mist
    const particleCount = 20;
    this.atmosphericParticles = [];

    for (let i = 0; i < particleCount; i++) {
      const particle = this.add.circle(
        Phaser.Math.Between(0, width),
        Phaser.Math.Between(0, height),
        Phaser.Math.Between(1, 3),
        0xffffff,
        Phaser.Math.FloatBetween(0.1, 0.3)
      );
      particle.setDepth(-8);
      particle.setBlendMode(Phaser.BlendModes.ADD);

      // Random slow floating motion
      this.tweens.add({
        targets: particle,
        x: particle.x + Phaser.Math.Between(-100, 100),
        y: particle.y + Phaser.Math.Between(-100, 100),
        duration: Phaser.Math.Between(8000, 15000),
        ease: 'Sine.easeInOut',
        yoyo: true,
        repeat: -1
      });

      this.atmosphericParticles.push(particle);
    }
  }

  createDimGraphic() {
    this.dimGraphic = this.add.graphics();
    this.dimGraphic.setAlpha(0.7);
    this.dimGraphic.fillStyle(BLACK_HEX_CODE, 1);
    this.dimGraphic.fillRect(0, 0, this.cameras.main.width, this.cameras.main.height);
  }

  restartGame() {
    this.dimGraphic.destroy();

    if (window.player) {
      window.player.reset();
    }

    for(let i in this.remotePlayers) {
      this.remotePlayers[i].reset();
    }

    this.deadGroup = [];
    this.lastFrameTime = null;

    // Phaser 3: Destroy old colliders before recreating map
    if (this.colliders) {
      this.colliders.forEach(collider => {
        if (collider && collider.destroy) {
          collider.destroy();
        }
      });
      this.colliders = [];
    }

    this.tearDownMap();
    this.tearDownAtmosphericEffects();
    this.initializeMap();
    this.createAtmosphericEffects();

    // Phaser 3: clear and recreate group
    this.bombs.clear(true, true);
    this.destroyItems();

    // Re-setup collisions
    if (window.player) {
      this.colliders.push(this.physics.add.collider(window.player, this.blockLayer));
      this.colliders.push(this.physics.add.collider(window.player, this.bombs));
    }

    this.gameFrozen = false;
    socket.emit("ready for round");
  }

  destroyItems() {
    for(let itemKey in this.items) {
      this.items[itemKey].destroy();
    }
    this.items = {};
  }

  celebrateWinners(winnerColors) {
    // Check if local player won
    if (window.player && window.player.active && winnerColors.includes(window.player.color)) {
      window.player.celebrate();
    }

    // Check remote players
    for (let id in this.remotePlayers) {
      const remotePlayer = this.remotePlayers[id];
      if (remotePlayer.active && winnerColors.includes(remotePlayer.color)) {
        remotePlayer.celebrate();
      }
    }
  }

  onNewRound(data) {
    // Trigger celebration for winning players
    this.celebrateWinners(data.roundWinnerColors);

    this.createDimGraphic();
    const animation = new RoundEndAnimation(this, data.completedRoundNumber, data.roundWinnerColors);
    this.gameFrozen = true;

    let roundImage;
    if(data.completedRoundNumber < 2) {
      roundImage = "round_text/round_" + (data.completedRoundNumber + 1) + ".png";
    } else if (data.completedRoundNumber == 2) {
      roundImage = "round_text/final_round.png";
    } else {
      roundImage = "round_text/tiebreaker.png";
    }

    animation.beginAnimation(() => {
      this.beginRoundAnimation(roundImage, this.restartGame.bind(this));
    });
  }

  onEndGame(data) {
    // Trigger celebration for winning players
    this.celebrateWinners(data.roundWinnerColors);

    this.createDimGraphic();
    this.gameFrozen = true;
    const animation = new RoundEndAnimation(this, data.completedRoundNumber, data.roundWinnerColors);
    animation.beginAnimation(() => {
      this.scene.start("GameOver", { gameWinnerColor: data.gameWinnerColor, noOpponents: false });
    });
  }

  onNoOpponentsLeft(data) {
    this.scene.start("GameOver", { gameWinnerColor: null, noOpponents: true });
  }

  beginRoundAnimation(image, callback) {
    const beginRoundText = this.add.image(-600, this.cameras.main.height / 2, TEXTURES, image);
    beginRoundText.setOrigin(0.5, 0.5);

    // Phaser 3: Chain tweens using onComplete
    this.tweens.add({
      targets: beginRoundText,
      x: this.cameras.main.width / 2,
      duration: 300,
      ease: 'Linear',
      onComplete: () => {
        // Wait 800ms then tween out
        this.time.delayedCall(800, () => {
          this.tweens.add({
            targets: beginRoundText,
            x: 1000,
            duration: 300,
            ease: 'Linear',
            onComplete: () => {
              if (this.dimGraphic) {
                this.dimGraphic.destroy();
              }
              beginRoundText.destroy();
              this.gameFrozen = false;

              if(callback) {
                callback();
              }
            }
          });
        });
      }
    });
  }

  update() {
    if(window.player != null && window.player.active) {
      if(this.gameFrozen) {
        window.player.freeze();
      } else {
        window.player.handleInput();

        // Check powerup overlaps
        for(let itemKey in this.items) {
          const item = this.items[itemKey];
          this.physics.overlap(window.player, item, () => {
            socket.emit("powerup overlap", {x: item.x, y: item.y});
          });
        }
      }
    }

    this.stopAnimationForMotionlessPlayers();
    this.storePreviousPositions();

    for(let id in this.remotePlayers) {
      this.remotePlayers[id].interpolate(this.lastFrameTime);
    }

    this.lastFrameTime = this.time.now;

    this.destroyDeadSprites();
  }

  destroyDeadSprites() {
    this.deadGroup.forEach((deadSprite) => {
      deadSprite.destroy();
    });
    this.deadGroup = [];
  }

  storePreviousPositions() {
    for(let id in this.remotePlayers) {
      const remotePlayer = this.remotePlayers[id];
      remotePlayer.previousPosition = {x: remotePlayer.x, y: remotePlayer.y};
    }
  }

  stopAnimationForMotionlessPlayers() {
    for(let id in this.remotePlayers) {
      const remotePlayer = this.remotePlayers[id];
      if(remotePlayer.lastMoveTime < this.time.now - 200) {
        remotePlayer.stop();
      }
    }
  }

  onSocketDisconnect() {
    console.log("Disconnected from socket server.");
  }

  initializePlayers() {
    for(let i in this.players) {
      const data = this.players[i];
      if(data.id == this.playerId) {
        window.player = new Player(this, data.x, data.y, data.id, data.color);
      } else {
        this.remotePlayers[data.id] = new RemotePlayer(this, data.x, data.y, data.id, data.color);
      }
    }
  }

  tearDownAtmosphericEffects() {
    if (this.backgroundGradient) {
      this.backgroundGradient.destroy();
    }
    if (this.ambientLight) {
      this.ambientLight.destroy();
    }
    if (this.atmosphericParticles) {
      this.atmosphericParticles.forEach(particle => particle.destroy());
      this.atmosphericParticles = [];
    }
  }

  tearDownMap() {
    if (this.map) {
      this.map.destroy();
    }
    if (this.groundLayer) {
      this.groundLayer.destroy();
    }
    if (this.blockLayer) {
      this.blockLayer.destroy();
    }
  }

  initializeMap() {
    // Phaser 3: tilemap creation changed significantly
    this.map = this.make.tilemap({ key: this.tilemapName });
    const mapInfo = MapInfo[this.tilemapName];

    const tileset = this.map.addTilesetImage(mapInfo.tilesetName, mapInfo.tilesetImage);

    // Phaser 3: createLayer instead of TilemapLayer constructor
    this.groundLayer = this.map.createLayer(mapInfo.groundLayer, tileset, 0, 0);
    this.blockLayer = this.map.createLayer(mapInfo.blockLayer, tileset, 0, 0);

    // Phaser 3: setCollision works similarly
    this.blockLayer.setCollisionByExclusion([-1]); // Collide with all tiles except -1 (empty)

    // Alternative: use specific collision tiles if needed
    // this.map.setCollision(mapInfo.collisionTiles, true, false, mapInfo.blockLayer);

    // Send map data to server
    const blockLayerData = this.cache.tilemap.get(this.tilemapName).data.layers[1];

    socket.emit("register map", {
      tiles: blockLayerData.data,
      height: blockLayerData.height,
      width: blockLayerData.width,
      destructibleTileId: mapInfo.destructibleTileId
    });
  }

  onMovePlayer(data) {
    if((window.player && data.id == window.player.id) || this.gameFrozen) {
      return;
    }

    const movingPlayer = this.remotePlayers[data.id];

    if (!movingPlayer) {
      return;
    }

    if(movingPlayer.targetPosition) {
      movingPlayer.play(`${movingPlayer.animKey}_${data.f}`, true);
      movingPlayer.lastMoveTime = this.time.now;

      if(data.x == movingPlayer.targetPosition.x && data.y == movingPlayer.targetPosition.y) {
        return;
      }

      movingPlayer.x = movingPlayer.targetPosition.x;
      movingPlayer.y = movingPlayer.targetPosition.y;

      movingPlayer.distanceToCover = {
        x: data.x - movingPlayer.targetPosition.x,
        y: data.y - movingPlayer.targetPosition.y
      };
      movingPlayer.distanceCovered = {x: 0, y: 0};
    }

    movingPlayer.targetPosition = {x: data.x, y: data.y};
  }

  onRemovePlayer(data) {
    const playerToRemove = this.remotePlayers[data.id];

    if(playerToRemove && playerToRemove.active) {
      playerToRemove.destroy();
    }

    delete this.remotePlayers[data.id];
    delete this.players[data.id];
  }

  onKillPlayer(data) {
    if(window.player && data.id == window.player.id) {
      console.log("You've been killed.");
      window.player.setActive(false);
      window.player.setVisible(false);
      if (window.player.shadow) {
        window.player.shadow.setVisible(false);
      }
    } else {
      const playerToRemove = this.remotePlayers[data.id];
      if (playerToRemove) {
        playerToRemove.setActive(false);
        playerToRemove.setVisible(false);
        if (playerToRemove.shadow) {
          playerToRemove.shadow.setVisible(false);
        }
      }
    }
  }

  onPlaceBomb(data) {
    const bomb = new Bomb(this, data.x, data.y, data.id);
    this.bombs.add(bomb);
  }

  onDetonate(data) {
    Bomb.renderExplosion(this, data.explosions);

    // Remove bomb from group
    this.bombs.getChildren().forEach((bomb) => {
      if(bomb && bomb.id == data.id) {
        bomb.remove();
      }
    });

    data.destroyedTiles.forEach((destroyedTile) => {
      // Phaser 3: removeTileAt
      this.map.removeTileAt(destroyedTile.col, destroyedTile.row, true, true, this.blockLayer);

      if(destroyedTile.itemId) {
        this.generateItemEntity(destroyedTile.itemId, destroyedTile.row, destroyedTile.col);
      }
    });
  }

  onPowerupAcquired(data) {
    if (this.items[data.powerupId]) {
      const item = this.items[data.powerupId];

      // Destroy glow effect if it exists
      if (item._glow) {
        item._glow.destroy();
      }

      // Create sparkle effect when collected
      const sparkles = this.add.particles(item.x + 20, item.y + 20, TEXTURES, {
        frame: 'gamesprites/bomb/bomb_01.png',
        speed: { min: 50, max: 100 },
        angle: { min: 0, max: 360 },
        scale: { start: 0.2, end: 0 },
        alpha: { start: 1, end: 0 },
        lifespan: 400,
        blendMode: 'ADD',
        tint: 0x00ffff,
        quantity: 10,
        duration: 100
      });
      sparkles.setDepth(15);

      // Clean up sparkles
      this.time.delayedCall(600, () => {
        sparkles.destroy();
      });

      item.destroy();
      delete this.items[data.powerupId];
    }

    if(window.player && data.acquiringPlayerId === window.player.id) {
      AudioPlayer.playPowerupSound();
      PowerupNotificationPlayer.showPowerupNotification(data.powerupType, window.player.x, window.player.y);
      if(data.powerupType == PowerupIDs.SPEED) {
        window.player.applySpeedPowerup();
      }
    }
  }

  generateItemEntity(itemId, row, col) {
    const imageKey = PowerupImageKeys[itemId];
    const item = this.physics.add.sprite(col * TILE_SIZE, row * TILE_SIZE, TEXTURES, imageKey);
    item.setOrigin(0, 0);
    this.items[row + "." + col] = item;
    item.setDepth(2);

    // Add glow effect to powerup
    const glow = this.add.circle(col * TILE_SIZE + 20, row * TILE_SIZE + 20, 25, 0x00ffff, 0);
    glow.setDepth(1);
    glow.setBlendMode(Phaser.BlendModes.ADD);

    // Pulsing glow animation
    this.tweens.add({
      targets: glow,
      alpha: 0.4,
      scale: 1.3,
      duration: 800,
      ease: 'Sine.easeInOut',
      yoyo: true,
      repeat: -1
    });

    // Floating animation
    this.tweens.add({
      targets: item,
      y: item.y - 5,
      duration: 1000,
      ease: 'Sine.easeInOut',
      yoyo: true,
      repeat: -1
    });

    // Store glow reference for cleanup
    item._glow = glow;
  }
}

module.exports = Level;

},{"../../../../common/map_info":21,"../../../../common/powerup_ids":22,"../entities/bomb":1,"../entities/player":2,"../entities/remoteplayer":3,"../entities/round_end_animation":4,"../util/audio_player":14,"../util/powerup_image_keys":16,"../util/powerup_notification_player":17}],9:[function(require,module,exports){
var TextConfigurer = require("../util/text_configurer");

const initialSlotYOffset = 130;
const slotXOffset = 40;
const lobbySlotDistance = 60;
const textXOffset = 260;
const textYOffset = 25;
const headerYOffset = 70;

let repeatingBombTilesprite;

class Lobby extends Phaser.Scene {
  constructor() {
    super({ key: 'Lobby' });
  }

  init(data) {
    repeatingBombTilesprite = data ? data.rbts : null;
  }

  create() {
    this.stateSettings = {
      empty: {
        outFrame: "lobby/slots/game_slot_01.png",
        overFrame: "lobby/slots/game_slot_02.png",
        text: "Host Game ",
        callback: this.hostGameAction
      },
      joinable: {
        outFrame: "lobby/slots/game_slot_03.png",
        overFrame: "lobby/slots/game_slot_04.png",
        text: "Join Game ",
        callback: this.joinGameAction
      },
      settingup: {
        outFrame: "lobby/slots/game_slot_05.png",
        overFrame: "lobby/slots/game_slot_05.png",
        text: "Game is being set up... ",
        callback: null
      },
      inprogress: {
        outFrame: "lobby/slots/game_slot_05.png",
        overFrame: "lobby/slots/game_slot_05.png",
        text: "Game in Progress ",
        callback: null
      },
      full: {
        outFrame: "lobby/slots/game_slot_05.png",
        overFrame: "lobby/slots/game_slot_05.png",
        text: "Game Full ",
        callback: null
      }
    };

    // Phaser 3: tileSprite
    if(repeatingBombTilesprite == null) {
      repeatingBombTilesprite = this.add.tileSprite(0, 0, 608, 608, "repeating_bombs");
      repeatingBombTilesprite.setOrigin(0, 0);
    }

    this.backdrop = this.add.image(12.5, 12.5, TEXTURES, "lobby/lobby_backdrop.png");
    this.backdrop.setOrigin(0, 0);

    this.header = this.add.text(this.cameras.main.width / 2, headerYOffset, "Lobby");
    this.header.setOrigin(0.5, 0.5);
    TextConfigurer.configureText(this.header, "white", 32);

    this.slots = [];
    this.labels = [];

    socket.emit("enter lobby");

    // Clean up old listeners
    socket.off("add slots");
    socket.off("update slot");

    socket.on("add slots", this.addSlots.bind(this));
    socket.on("update slot", this.updateSlot.bind(this));
  }

  update() {
    if (repeatingBombTilesprite) {
      repeatingBombTilesprite.tilePositionX++;
      repeatingBombTilesprite.tilePositionY--;
    }
  }

  addSlots(gameData) {
    if(this.slots.length > 0) {
      return;
    }

    for(let i = 0; i < gameData.length; i++) {
      let callback = null;
      const state = gameData[i].state;
      const settings = this.stateSettings[state];

      // Create closure for callback
      if(settings.callback != null) {
        callback = () => {
          settings.callback.call(this, i);
        };
      }

      const slotYOffset = initialSlotYOffset + i * lobbySlotDistance;

      // Phaser 3: Interactive image instead of button
      this.slots[i] = this.add.image(slotXOffset, slotYOffset, TEXTURES, settings.outFrame);
      this.slots[i].setOrigin(0, 0);

      if (callback) {
        this.slots[i].setInteractive();

        this.slots[i].on('pointerover', () => {
          this.slots[i].setFrame(settings.overFrame);
        });

        this.slots[i].on('pointerout', () => {
          this.slots[i].setFrame(settings.outFrame);
        });

        this.slots[i].on('pointerdown', () => {
          window.buttonClickSound.play();
          callback();
        });
      }

      const text = this.add.text(slotXOffset + textXOffset, slotYOffset + textYOffset, settings.text);
      TextConfigurer.configureText(text, "white", 18);
      text.setOrigin(0.5, 0.5);

      this.labels[i] = text;
    }
  }

  hostGameAction(gameId) {
    socket.emit("host game", {gameId: gameId});
    socket.removeAllListeners();
    this.scene.start("StageSelect", { gameId: gameId, rbts: repeatingBombTilesprite });
  }

  joinGameAction(gameId) {
    socket.removeAllListeners();
    this.scene.start("PendingGame", { tilemapName: null, gameId: gameId, rbts: repeatingBombTilesprite });
  }

  updateSlot(updateInfo) {
    const settings = this.stateSettings[updateInfo.newState];
    const id = updateInfo.gameId;
    const button = this.slots[id];

    this.labels[id].setText(settings.text);
    button.setFrame(settings.outFrame);

    // Remove old listeners
    button.removeAllListeners();

    // Add new callback if available
    if (settings.callback) {
      button.setInteractive();

      button.on('pointerover', () => {
        button.setFrame(settings.overFrame);
      });

      button.on('pointerout', () => {
        button.setFrame(settings.outFrame);
      });

      button.on('pointerdown', () => {
        window.buttonClickSound.play();
        settings.callback.call(this, id);
      });
    } else {
      button.disableInteractive();
    }
  }
}

module.exports = Lobby;

},{"../util/text_configurer":18}],10:[function(require,module,exports){
var TextConfigurer = require('../util/text_configurer');

const xOffset = 40;
const yOffset = 50;
const buttonXOffset = 330;
const startGameButtonYOffset = 400;
const leaveButtonYOffset = 450;
const characterSquareStartingX = 330;
const characterSquareStartingY = 80;
const characterSquareXDistance = 105;
const characterSquareYDistance = 100;
const characterOffsetX = 4.5;
const characterOffsetY = 4.5;
const minPlayerMessageOffsetX = 80;
const minPlayerMessageOffsetY = 400;
const numCharacterSquares = 6;

let repeatingBombTilesprite;

class PendingGame extends Phaser.Scene {
  constructor() {
    super({ key: 'PendingGame' });
  }

  init(data) {
    this.tilemapName = data.tilemapName;
    this.gameId = data.gameId;
    repeatingBombTilesprite = data.rbts;
  }

  create() {
    socket.emit("enter pending game", {gameId: this.gameId});

    const backdrop = this.add.image(xOffset, yOffset, TEXTURES, "lobby/backdrop.png");
    backdrop.setOrigin(0, 0);

    // Start game button (initially disabled)
    this.startGameButton = this.add.image(buttonXOffset, startGameButtonYOffset, TEXTURES, "lobby/buttons/start_game_button_03.png");
    this.startGameButton.setOrigin(0, 0);

    // Leave game button
    this.leaveGameButton = this.add.image(buttonXOffset, leaveButtonYOffset, TEXTURES, "lobby/buttons/leave_game_button_01.png");
    this.leaveGameButton.setOrigin(0, 0);
    this.leaveGameButton.setInteractive();

    this.leaveGameButton.on('pointerover', () => {
      this.leaveGameButton.setFrame("lobby/buttons/leave_game_button_02.png");
    });

    this.leaveGameButton.on('pointerout', () => {
      this.leaveGameButton.setFrame("lobby/buttons/leave_game_button_01.png");
    });

    this.leaveGameButton.on('pointerdown', () => {
      window.buttonClickSound.play();
      this.leaveGameAction();
    });

    this.characterSquares = this.drawCharacterSquares(4);
    this.characterImages = [];
    this.numPlayersInGame = 0;

    this.minPlayerMessage = this.add.text(minPlayerMessageOffsetX, minPlayerMessageOffsetY, "Cannot start game without\nat least 2 players.");
    TextConfigurer.configureText(this.minPlayerMessage, "red", 17);
    this.minPlayerMessage.visible = false;

    socket.on("show current players", this.populateCharacterSquares.bind(this));
    socket.on("player joined", this.playerJoined.bind(this));
    socket.on("player left", this.playerLeft.bind(this));
    socket.on("start game on client", this.startGame.bind(this));
  }

  update() {
    if (repeatingBombTilesprite) {
      repeatingBombTilesprite.tilePositionX++;
      repeatingBombTilesprite.tilePositionY--;
    }
  }

  drawCharacterSquares(numOpenings) {
    const characterSquares = [];
    let yOff = characterSquareStartingY;
    let xOff = characterSquareStartingX;

    for(let i = 0; i < numCharacterSquares; i++) {
      const frame = i < numOpenings ? "lobby/slots/character_square_01.png" : "lobby/slots/character_square_02.png";
      characterSquares[i] = this.add.sprite(xOff, yOff, TEXTURES, frame);
      characterSquares[i].setOrigin(0, 0);

      if(i % 2 == 0) {
        xOff += characterSquareXDistance;
      } else {
        xOff = characterSquareStartingX;
        yOff += characterSquareYDistance;
      }
    }

    return characterSquares;
  }

  populateCharacterSquares(data) {
    this.numPlayersInGame = 0;

    for(let playerId in data.players) {
      const color = data.players[playerId].color;
      this.characterImages[playerId] = this.add.image(
        this.characterSquares[this.numPlayersInGame].x + characterOffsetX,
        this.characterSquares[this.numPlayersInGame].y + characterOffsetY,
        TEXTURES,
        "lobby/bomberman_head/bomberman_head_" + color + ".png"
      );
      this.characterImages[playerId].setOrigin(0, 0);
      this.numPlayersInGame++;
    }

    if(this.numPlayersInGame > 1) {
      this.activateStartGameButton();
    } else {
      this.minPlayerMessage.visible = true;
    }
  }

  playerJoined(data) {
    this.numPlayersInGame++;
    const index = this.numPlayersInGame - 1;

    this.characterImages[data.id] = this.add.image(
      this.characterSquares[index].x + characterOffsetX,
      this.characterSquares[index].y + characterOffsetY,
      TEXTURES,
      "lobby/bomberman_head/bomberman_head_" + data.color + ".png"
    );
    this.characterImages[data.id].setOrigin(0, 0);

    // Activate start game button if this is the second player
    if(this.numPlayersInGame == 2) {
      this.activateStartGameButton();
    }
  }

  activateStartGameButton() {
    this.minPlayerMessage.visible = false;
    this.startGameButton.setFrame("lobby/buttons/start_game_button_01.png");
    this.startGameButton.setInteractive();

    this.startGameButton.removeAllListeners();

    this.startGameButton.on('pointerover', () => {
      this.startGameButton.setFrame("lobby/buttons/start_game_button_02.png");
    });

    this.startGameButton.on('pointerout', () => {
      this.startGameButton.setFrame("lobby/buttons/start_game_button_01.png");
    });

    this.startGameButton.on('pointerdown', () => {
      window.buttonClickSound.play();
      this.startGameAction();
    });
  }

  deactivateStartGameButton() {
    this.minPlayerMessage.visible = true;
    this.startGameButton.setFrame("lobby/buttons/start_game_button_03.png");
    this.startGameButton.removeAllListeners();
    this.startGameButton.disableInteractive();
  }

  playerLeft(data) {
    this.numPlayersInGame--;

    if(this.numPlayersInGame == 1) {
      this.deactivateStartGameButton();
    }

    for(let playerId in this.characterImages) {
      this.characterImages[playerId].destroy();
    }
    this.populateCharacterSquares(data);
  }

  startGameAction() {
    socket.emit("start game on server");
  }

  leaveGameAction() {
    socket.emit("leave pending game");
    socket.removeAllListeners();
    this.scene.start("Lobby", { rbts: repeatingBombTilesprite });
  }

  startGame(data) {
    socket.removeAllListeners();
    this.scene.start("Level", { tilemapName: data.mapName, players: data.players, id: socket.id });
  }
}

module.exports = PendingGame;

},{"../util/text_configurer":18}],11:[function(require,module,exports){
var TextConfigurer = require("../util/text_configurer");

class Preloader extends Phaser.Scene {
  constructor() {
    super({ key: 'Preloader' });
    console.log("[PRELOADER] Scene constructor called");
  }

  displayLoader() {
    console.log("[PRELOADER] Setting up loader display");
    // Phaser 3: this.add instead of game.add, this.cameras.main instead of game.camera
    this.text = this.add.text(this.cameras.main.width / 2, 250, "Loading... ");
    this.text.setOrigin(0.5, 0.5); // Phaser 3: setOrigin instead of anchor.setTo
    TextConfigurer.configureText(this.text, "white", 32);

    // Phaser 3: load events are different
    this.load.on('progress', (progress) => {
      this.text.setText("Loading... " + Math.floor(progress * 100) + "%");
    });

    this.load.on('complete', () => {
      this.scene.start("TitleScreen");
    });
  }

  preload() {
    console.log("[PRELOADER] Starting asset preload");
    this.displayLoader();

    // Phaser 3: atlas method changed
    console.log("[PRELOADER] Loading texture atlas");
    this.load.atlas("bbo_textures", "assets/textures/bbo_textures.png", "assets/textures/bbo_textures.json");

    // Phaser 3: tilemapTiledJSON instead of tilemap
    console.log("[PRELOADER] Loading tilemaps");
    this.load.tilemapTiledJSON("levelOne", "assets/levels/level_one.json");
    this.load.tilemapTiledJSON("levelTwo", "assets/levels/level_two.json");
    this.load.image("tiles", "assets/tiles/tileset.png");
    this.load.image("repeating_bombs", "/assets/repeating_bombs.png");

    // Phaser 3: audio loading is the same
    console.log("[PRELOADER] Loading audio");
    this.load.audio("explosion", "assets/sounds/bomb.ogg");
    this.load.audio("powerup", "assets/sounds/powerup.ogg");
    this.load.audio("click", "assets/sounds/click.ogg");

    this.load.on('loaderror', (file) => {
      console.error("[PRELOADER] Error loading file:", file.key, file.src);
    });
  }

  create() {
    // Phaser 3: sound.add instead of new Phaser.Sound
    window.buttonClickSound = this.sound.add("click", { volume: 0.25 });
  }
}

module.exports = Preloader;

},{"../util/text_configurer":18}],12:[function(require,module,exports){
const xOffset = 40;
const yOffset = 50;
const thumbnailXOffset = 255;
const thumbnailYOffset = 150;
const stageNameYOffset = 328;

let repeatingBombTilesprite;

const stages = [
  {name: "Limitless Brook", thumbnailKey: "thumbnails/limitless_brook_thumbnail.png", tilemapName: "levelOne", maxPlayers: 4, size: "small"},
  {name: "Danger Desert", thumbnailKey: "thumbnails/danger_desert_thumbnail.png", tilemapName: "levelTwo", maxPlayers: 4, size: "medium"}
];

class StageSelect extends Phaser.Scene {
  constructor() {
    super({ key: 'StageSelect' });
  }

  init(data) {
    repeatingBombTilesprite = data.rbts;
    this.gameId = data.gameId;
  }

  create() {
    const selectionWindow = this.add.image(xOffset, yOffset, TEXTURES, "lobby/select_stage.png");
    selectionWindow.setOrigin(0, 0);

    this.selectedStageIndex = 0;
    const initialStage = stages[this.selectedStageIndex];

    // Phaser 3: Interactive images instead of buttons
    this.leftButton = this.add.image(150, 180, TEXTURES, "lobby/buttons/left_select_button_01.png");
    this.leftButton.setOrigin(0, 0);
    this.leftButton.setInteractive();

    this.leftButton.on('pointerover', () => {
      this.leftButton.setFrame("lobby/buttons/left_select_button_02.png");
    });

    this.leftButton.on('pointerout', () => {
      this.leftButton.setFrame("lobby/buttons/left_select_button_01.png");
    });

    this.leftButton.on('pointerdown', () => {
      window.buttonClickSound.play();
      this.leftSelect();
    });

    this.rightButton = this.add.image(400, 180, TEXTURES, "lobby/buttons/right_select_button_01.png");
    this.rightButton.setOrigin(0, 0);
    this.rightButton.setInteractive();

    this.rightButton.on('pointerover', () => {
      this.rightButton.setFrame("lobby/buttons/right_select_button_02.png");
    });

    this.rightButton.on('pointerout', () => {
      this.rightButton.setFrame("lobby/buttons/right_select_button_01.png");
    });

    this.rightButton.on('pointerdown', () => {
      window.buttonClickSound.play();
      this.rightSelect();
    });

    this.okButton = this.add.image(495, 460, TEXTURES, "lobby/buttons/ok_button_01.png");
    this.okButton.setOrigin(0, 0);
    this.okButton.setInteractive();

    this.okButton.on('pointerover', () => {
      this.okButton.setFrame("lobby/buttons/ok_button_02.png");
    });

    this.okButton.on('pointerout', () => {
      this.okButton.setFrame("lobby/buttons/ok_button_01.png");
    });

    this.okButton.on('pointerdown', () => {
      window.buttonClickSound.play();
      this.confirmStageSelection();
    });

    this.thumbnail = this.add.image(thumbnailXOffset, thumbnailYOffset, TEXTURES, initialStage.thumbnailKey);
    this.thumbnail.setOrigin(0, 0);

    // Display title
    this.text = this.add.text(this.cameras.main.width / 2, stageNameYOffset, initialStage.name);
    this.configureText(this.text, "white", 28);
    this.text.setOrigin(0.5, 0.5);

    // Display number of players
    this.numPlayersText = this.add.text(145, 390, "Max # of players:   " + initialStage.maxPlayers);
    this.configureText(this.numPlayersText, "white", 18);

    // Display stage size
    this.stageSizeText = this.add.text(145, 420, "Map size:   " + initialStage.size);
    this.configureText(this.stageSizeText, "white", 18);
  }

  leftSelect() {
    if(this.selectedStageIndex === 0) {
      this.selectedStageIndex = stages.length - 1;
    } else {
      this.selectedStageIndex--;
    }

    this.updateStageInfo();
  }

  rightSelect() {
    if(this.selectedStageIndex === stages.length - 1) {
      this.selectedStageIndex = 0;
    } else {
      this.selectedStageIndex++;
    }

    this.updateStageInfo();
  }

  update() {
    if (repeatingBombTilesprite) {
      repeatingBombTilesprite.tilePositionX++;
      repeatingBombTilesprite.tilePositionY--;
    }
  }

  updateStageInfo() {
    const newStage = stages[this.selectedStageIndex];
    this.text.setText(newStage.name);
    this.numPlayersText.setText("Max # of players:   " + newStage.maxPlayers);
    this.stageSizeText.setText("Map size:   " + newStage.size);
    this.thumbnail.setFrame(newStage.thumbnailKey);
  }

  configureText(text, color, size) {
    text.setFontFamily("Carter One");
    text.setColor(color);
    text.setFontSize(size);
  }

  confirmStageSelection() {
    const selectedStage = stages[this.selectedStageIndex];

    socket.emit("select stage", {mapName: selectedStage.tilemapName});
    this.scene.start("PendingGame", { tilemapName: selectedStage.tilemapName, gameId: this.gameId, rbts: repeatingBombTilesprite });
  }
}

module.exports = StageSelect;

},{}],13:[function(require,module,exports){
var Fader = require("../util/fader");

class TitleScreen extends Phaser.Scene {
  constructor() {
    super({ key: 'TitleScreen' });
  }

  create() {
    this.showingInstructions = false;
    this.justClickedHowTo = false;
    this.justClickedOutOfHowTo = false;

    this.createClouds();
    this.createButtons();

    var startButtonTween = this.createInitialButtonTween(this.startButton, 200);
    var howToButtonTween = this.createInitialButtonTween(this.howToButton, 400);

    var title = this.add.image(55, 20 - 200, TEXTURES, "titlescreen/title.png");
    title.setOrigin(0, 0);

    // Phaser 3: tweens.add instead of game.add.tween
    this.tweens.add({
      targets: title,
      y: 20,
      duration: 500,
      ease: 'Bounce.easeOut',
      delay: 200
    });

    var bomberman = this.add.sprite(305 + 400, 265, TEXTURES, "titlescreen/bomberman/bomberman_01.png");
    bomberman.setOrigin(0, 0);

    // Phaser 3: anims.create for animations
    this.anims.create({
      key: 'bomb_animation',
      frames: [
        { key: TEXTURES, frame: "titlescreen/bomberman/bomberman_01.png" },
        { key: TEXTURES, frame: "titlescreen/bomberman/bomberman_02.png" },
        { key: TEXTURES, frame: "titlescreen/bomberman/bomberman_03.png" },
        { key: TEXTURES, frame: "titlescreen/bomberman/bomberman_04.png" },
        { key: TEXTURES, frame: "titlescreen/bomberman/bomberman_05.png" }
      ],
      frameRate: 5,
      repeat: -1
    });

    this.tweens.add({
      targets: bomberman,
      x: 305,
      duration: 300,
      ease: 'Linear',
      delay: 100,
      onComplete: () => {
        bomberman.play("bomb_animation");
      }
    });
  }

  createInitialButtonTween(button, delay) {
    return this.tweens.add({
      targets: button,
      x: 40,
      duration: 300,
      ease: 'Linear',
      delay: delay
    });
  }

  createClouds() {
    const cloudRightmostPointX = 700;
    const cloudLeftmostPointX = -260;
    const cloudTweenDuration = 80000;
    const tweenDuration = cloudTweenDuration * (this.cameras.main.width - cloudLeftmostPointX) / this.cameras.main.width;

    this.add.image(0, 0, TEXTURES, "titlescreen/background.png").setOrigin(0, 0);

    const cloudData = [
      {startingX: 400, startingY: 50, image: "cloud1"},
      {startingX: -150, startingY: 140, image: "cloud1"},
      {startingX: 375, startingY: 200, image: "cloud1"},
      {startingX: 330, startingY: -20, image: "cloud1"},
      {startingX: 110, startingY: 110, image: "cloud2"},
      {startingX: -300, startingY: 140, image: "cloud2"},
      {startingX: -300, startingY: -30, image: "cloud2"},
      {startingX: 0, startingY: 140, image: "cloud3"},
      {startingX: -75, startingY: 200, image: "cloud4"},
      {startingX: 200, startingY: 20, image: "cloud5"},
      {startingX: 100, startingY: -20, image: "cloud5"},
      {startingX: -200, startingY: 250, image: "cloud6"},
      {startingX: 40, startingY: 80, image: "cloud7"},
      {startingX: 200, startingY: 180, image: "cloud1"},
      {startingX: -150, startingY: 20, image: "cloud5"},
      {startingX: 300, startingY: 230, image: "cloud4"}
    ];

    for(let x = 0; x < cloudData.length; x++) {
      const data = cloudData[x];
      const cloudImage = this.add.image(data.startingX, data.startingY, TEXTURES, "titlescreen/" + data.image + ".png");
      cloudImage.setOrigin(0, 0);

      const initialTweenDuration = cloudTweenDuration * (this.cameras.main.width - data.startingX) / this.cameras.main.width;

      this.tweens.add({
        targets: cloudImage,
        x: cloudRightmostPointX,
        duration: initialTweenDuration,
        ease: 'Linear',
        onComplete: () => {
          cloudImage.x = cloudLeftmostPointX;
          this.tweens.add({
            targets: cloudImage,
            x: cloudRightmostPointX,
            duration: tweenDuration,
            ease: 'Linear',
            repeat: -1
          });
        }
      });
    }
  }

  createButtons() {
    // Phaser 3: Buttons are now interactive images
    this.startButton = this.add.image(40 - 250, 275, TEXTURES, "titlescreen/buttons/startbutton_01.png");
    this.startButton.setOrigin(0, 0);
    this.startButton.setInteractive();

    this.startButton.on('pointerover', () => {
      this.startButton.setFrame("titlescreen/buttons/startbutton_02.png");
    });

    this.startButton.on('pointerout', () => {
      this.startButton.setFrame("titlescreen/buttons/startbutton_01.png");
    });

    this.startButton.on('pointerdown', () => {
      if(!this.showingInstructions && !this.justClickedOutOfHowTo) {
        window.buttonClickSound.play();
        Fader.fadeOut(() => {
          this.scene.start("Lobby");
        });
      }
    });

    this.howToButton = this.add.image(40 - 250, 360, TEXTURES, "titlescreen/buttons/howtobutton_01.png");
    this.howToButton.setOrigin(0, 0);
    this.howToButton.setInteractive();

    this.howToButton.on('pointerover', () => {
      this.howToButton.setFrame("titlescreen/buttons/howtobutton_02.png");
    });

    this.howToButton.on('pointerout', () => {
      this.howToButton.setFrame("titlescreen/buttons/howtobutton_01.png");
    });

    this.howToButton.on('pointerdown', () => {
      if(!this.showingInstructions && !this.justClickedOutOfHowTo) {
        window.buttonClickSound.play();
        this.showingInstructions = true;
        Fader.fadeOut(() => {
          this.howTo = this.add.image(0, 0, TEXTURES, "titlescreen/howtoplay.png");
          this.howTo.setOrigin(0, 0);
          this.justClickedHowTo = true;
          Fader.fadeIn();
        }, this);
      }
    });
  }

  update() {
    // Phaser 3: activePointer is now this.input.activePointer
    if(!this.input.activePointer.isDown && this.justClickedHowTo) {
      this.justClickedHowTo = false;
    }

    if(!this.input.activePointer.isDown && this.justClickedOutOfHowTo) {
      this.justClickedOutOfHowTo = false;
    }

    if(this.input.activePointer.isDown && this.showingInstructions && !this.justClickedHowTo) {
      window.buttonClickSound.play();
      this.showingInstructions = false;
      this.justClickedOutOfHowTo = true;
      Fader.fadeOut(() => {
        this.howTo.destroy();
        Fader.fadeIn();
      }, this);
    }
  }
}

module.exports = TitleScreen;

},{"../util/fader":15}],14:[function(require,module,exports){
// Phaser 3: Audio system updated
// Note: Sounds are now created in scenes, so we store references
var bombSound;
var powerupSound;

module.exports = {
  initialize: function() {
    // Sounds are created in Boot scene via this.sound.add
    // We'll access them through the global game object
    // This will be set in the Preloader scene
  },

  playBombSound: function() {
    // Access current scene's sound manager
    if (window.game && window.game.scene && window.game.scene.scenes[0]) {
      const scene = window.game.scene.getScene('Level') || window.game.scene.scenes[0];
      if (scene && scene.sound) {
        scene.sound.play("explosion");
      }
    }
  },

  playPowerupSound: function() {
    if (window.game && window.game.scene && window.game.scene.scenes[0]) {
      const scene = window.game.scene.getScene('Level') || window.game.scene.scenes[0];
      if (scene && scene.sound) {
        scene.sound.play("powerup");
      }
    }
  }
}

},{}],15:[function(require,module,exports){
// Phaser 3: Fader utility needs scene context
const BLACK_HEX_CODE = 0x000000;

module.exports = {
  fadeGraphic: null,

  createFadeTween: function(scene, alphaFrom, alphaTo, fadeDuration) {
    fadeDuration = fadeDuration || 300;

    if(this.fadeGraphic) {
      this.fadeGraphic.destroy();
    }

    // Phaser 3: graphics API changed
    this.fadeGraphic = scene.add.graphics();
    this.fadeGraphic.fillStyle(BLACK_HEX_CODE, 1);
    this.fadeGraphic.fillRect(0, 0, scene.cameras.main.width, scene.cameras.main.height);
    this.fadeGraphic.setScrollFactor(0); // Phaser 3: equivalent to fixedToCamera

    this.fadeGraphic.setAlpha(alphaFrom);

    // Phaser 3: tweens.add instead of game.add.tween
    const tween = scene.tweens.add({
      targets: this.fadeGraphic,
      alpha: alphaTo,
      duration: fadeDuration,
      ease: 'Linear',
      paused: true
    });

    return tween;
  },

  createFadeInTween: function(scene, fadeDuration) {
    return this.createFadeTween(scene, 1, 0, fadeDuration);
  },

  createFadeOutTween: function(scene, fadeDuration) {
    return this.createFadeTween(scene, 0, 1, fadeDuration);
  },

  fadeOut: function(callback, callbackContext, fadeDuration) {
    // Get current active scene - check running scenes
    const scene = window.game.scene.scenes.find(s => s.scene.isActive() || s.scene.settings.status === 6);
    if (!scene) {
      console.error('[FADER] No active scene found for fadeOut');
      return;
    }

    callbackContext = callbackContext || this;

    const fadeOutTween = this.createFadeOutTween(scene, fadeDuration);

    if(typeof callback === 'function') {
      fadeOutTween.on('complete', callback, callbackContext);
    }

    fadeOutTween.play();
  },

  fadeIn: function(callback, callbackContext, fadeDuration) {
    const scene = window.game.scene.scenes.find(s => s.scene.isActive() || s.scene.settings.status === 6);
    if (!scene) {
      console.error('[FADER] No active scene found for fadeIn');
      return;
    }

    callbackContext = callbackContext || this;

    const fadeInTween = this.createFadeInTween(scene, fadeDuration);

    if(typeof callback === 'function') {
      fadeInTween.on('complete', callback, callbackContext);
    }

    fadeInTween.play();
  }
}

},{}],16:[function(require,module,exports){
var PowerupIDs = require("../../../../common/powerup_ids");

var powerupImageKeys = {};

powerupImageKeys[PowerupIDs.BOMB_STRENGTH] = "gamesprites/bomb_strength_powerup.png";
powerupImageKeys[PowerupIDs.BOMB_CAPACITY] = "gamesprites/bomb_count_powerup.png";
powerupImageKeys[PowerupIDs.SPEED] = "gamesprites/speed_powerup.png";

module.exports = powerupImageKeys;
},{"../../../../common/powerup_ids":22}],17:[function(require,module,exports){
var PowerupIds = require("../../../../common/powerup_ids");

var notificationImageMap = {};
notificationImageMap[PowerupIds.BOMB_STRENGTH] = "gamesprites/bomb_strength_notification.png";
notificationImageMap[PowerupIds.BOMB_CAPACITY] = "gamesprites/bomb_count_notification.png";
notificationImageMap[PowerupIds.SPEED] = "gamesprites/speed_notification.png";

exports.showPowerupNotification = function(powerupId, playerX, playerY) {
  // Get the Level scene
  const scene = window.game.scene.getScene('Level');
  if (!scene) return;

  const notificationImageKey = notificationImageMap[powerupId];

  // Phaser 3: add.image instead of new Phaser.Image
  const image = scene.add.image(playerX, playerY - 10, TEXTURES, notificationImageKey);
  image.setOrigin(0.5, 0.5);

  // Phaser 3: tweens.add for both tweens
  scene.tweens.add({
    targets: image,
    y: image.y - 30,
    duration: 600,
    ease: 'Linear'
  });

  scene.tweens.add({
    targets: image,
    alpha: 0,
    duration: 600,
    ease: 'Linear',
    onComplete: () => {
      image.destroy();
    }
  });
}

},{"../../../../common/powerup_ids":22}],18:[function(require,module,exports){
// Phaser 3: Text configuration API changed
exports.configureText = function(text, color, size) {
  text.setFontFamily("Carter One");
  text.setColor(color);
  text.setFontSize(size);
}

},{}],19:[function(require,module,exports){
module.exports = {
	getFrames: function (getFrameFunction, prefix, numbers) {
  		var frames = [];
  		numbers.forEach(function(number) {
  		  frames.push(getFrameFunction(prefix, number));
  		});
  		return frames;
	}
}
},{}],20:[function(require,module,exports){
console.log("[MAIN] Starting Bomb Arena...");
console.log("[MAIN] Phaser version:", Phaser.VERSION);

// Phaser 3 uses config object for initialization
const config = {
    type: Phaser.AUTO,
    width: 600,
    height: 600,
    parent: '',
    physics: {
        default: 'arcade',
        arcade: {
            debug: true // Enable debug to see collision boxes
        }
    },
    scene: [
        require("./game/states/boot"),
        require("./game/states/preloader"),
        require("./game/states/title_screen"),
        require("./game/states/lobby"),
        require("./game/states/stage_select"),
        require("./game/states/pending_game"),
        require("./game/states/level"),
        require("./game/states/game_over")
    ]
};

console.log("[MAIN] Config created, initializing Phaser game...");

// Global references (to be migrated to scene data/registry)
try {
    window.game = new Phaser.Game(config);
    console.log("[MAIN] Phaser game instance created successfully");
} catch (error) {
    console.error("[MAIN] Error creating Phaser game:", error);
    throw error;
}

window.player = null;
window.socket = null;
window.level = null;
window.TEXTURES = "bbo_textures";

startGame();

function startGame() {
    console.log("[MAIN] Connecting to socket.io server...");
    try {
        socket = io("http://localhost:8007"); // TODO check port already used

        socket.on('connect', function() {
            console.log("[SOCKET] Connected to server, socket ID:", socket.id);
        });

        socket.on('connect_error', function(error) {
            console.error("[SOCKET] Connection error:", error);
        });

        socket.on('disconnect', function(reason) {
            console.log("[SOCKET] Disconnected:", reason);
        });

        console.log("[MAIN] Socket.io connection initiated");
    } catch (error) {
        console.error("[MAIN] Error connecting to socket:", error);
    }

    // Phaser enhancements will need to be updated for Phaser 3
    try {
        require("./game/mods/phaser_enhancements");
        console.log("[MAIN] Phaser enhancements loaded");
    } catch (error) {
        console.error("[MAIN] Error loading phaser enhancements:", error);
    }

    console.log("[MAIN] Initialization complete");
}
},{"./game/mods/phaser_enhancements":5,"./game/states/boot":6,"./game/states/game_over":7,"./game/states/level":8,"./game/states/lobby":9,"./game/states/pending_game":10,"./game/states/preloader":11,"./game/states/stage_select":12,"./game/states/title_screen":13}],21:[function(require,module,exports){
var MapInfo = {
	levelOne: {
		spawnLocations: [{x: 2, y: 5}, {x: 13, y: 1}, {x: 3, y: 1}, {x: 12, y: 6}],
		collisionTiles: [127, 361],
		groundLayer: "Ground",
		blockLayer: "Blocks",
		tilesetName: "tiles",
		tilesetImage: "tiles",
		destructibleTileId: 361
	},
	levelTwo: {
		spawnLocations: [{x: 2, y: 1}, {x: 13, y: 1}, {x: 2, y: 13}, {x: 13, y: 13}],
		collisionTiles: [169, 191],
		groundLayer: "Ground",
		blockLayer: "Blocks",
		tilesetName: "tiles",
		tilesetImage: "tiles",
		destructibleTileId: 191
	}
};

module.exports = MapInfo;
},{}],22:[function(require,module,exports){
module.exports = {
	BOMB_STRENGTH: 5,

	BOMB_CAPACITY: 6,

	SPEED: 7,

	isAPowerup: function(id) {
		return id === this.BOMB_STRENGTH || id === this.BOMB_CAPACITY || id === this.SPEED;
	}
}
},{}]},{},[20]);
